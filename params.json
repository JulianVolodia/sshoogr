{"name":"Sshoogr","tagline":"A Groovy-based DSL for working with remote SSH servers.","body":"# groovy-ssh-dsl\r\n\r\n## Overview\r\n\r\nThe `groovy-ssh-dsl` is a **Groovy**-based **DSL** library for working with remote servers through **SSH**. The **DSL** allows:\r\n\r\n- connecting\r\n- executing remote commands\r\n- copying files and directories\r\n- creating tunnels in a simple and concise way.\r\n\r\nThe library was jointly developed by **Aestas/IT** (http://aestasit.com) and **NetCompany A/S** (http://www.netcompany.com/) to support the quickly growing company's operations and hosting department.\r\n\r\n## Usage\r\n\r\nThe easiest way to use `gradle-ssh-dsl` in a **Groovy** script is by importing the dependency using [Grape](http://groovy.codehaus.org/Grape).\r\n\r\n    @GrabResolver(name='oss', root='https://oss.sonatype.org/content/repositories/snapshots/')\r\n    @Grab('com.aestasit.gradle:gradle-ssh-plugin:0.8-SNAPSHOT')\r\n\r\n### Creating a SshDslEngine instance\r\n\r\nThe main library's classes are `SshDslEngine` and `SshOptions`, which need to be imported before the library can be used:\r\n    \r\n    import com.aestasit.ssh.dsl.SshDslEngine\r\n    import com.aestasit.ssh.SshOptions\r\n\r\nTo create a simple instance of the engine with the default options you can just use the following instruction:\r\n\r\n    def engine = new SshDslEngine(new SshOptions())\r\n\r\n### Basic usage\r\n\r\nThe entry point for using the **DSL** is the `remoteSession` method, which accepts an **SSH** **URL** and a closure with **Groovy** or **DSL** code:\r\n\r\n    engine.remoteSession('user2:654321@localhost:2222') {\r\n      exec 'rm -rf /tmp/*'\r\n      exec 'touch /var/lock/my.pid'\r\n      remoteFile('/var/my.conf').text = \"enabled=true\"\r\n    }\r\n\r\nFor more examples, please refer to the following sections.\r\n\r\n### Remote connections\r\n\r\nThe `remoteSession` method accepts an **SSH** **URL** and a closure, for example:\r\n\r\n    engine.remoteSession(\"user:password@localhost:22\") {\r\n      ...\r\n    }\r\n\r\nInside the closure you can execute remote commands, access remote file content, upload and download files, create tunnels.\r\n\r\nIf your connection settings were set with the help of default configuration (see \"Configuration options\" section),\r\nthen you can omit the **URL** parameter:\r\n\r\n    engine.remoteSession {\r\n      ...\r\n    }\r\n\r\nFurthermore, it is possible to override the default values in each session by directly assigning `host`, `username`, `password` and `port` properties:\r\n\r\n    engine.remoteSession {\r\n\r\n      host = 'localhost'\r\n      username = 'user2'\r\n      password = '654321'\r\n      port = 2222\r\n\r\n      ...\r\n\r\n    }\r\n\r\nThe **SSH**'s **URL** can be also assigned from withing the remote session declaration, like so:\r\n\r\n    engine.remoteSession {\r\n\r\n      url = 'user2:654321@localhost:2222'\r\n\r\n      ...\r\n\r\n    }\r\n\r\nThe actual connection to the remote host will be executed upon the first command or file access, and, naturally, the connection will be\r\nautomatically closed after the code block terminates.\r\n\r\nYou can explicitly call `connect` or `disconnect` methods to control this behavior:\r\n\r\n    engine.remoteSession {\r\n\r\n      // explicitly call connect\r\n      connect()\r\n\r\n      // do some stuff\r\n      ...\r\n\r\n      // explicitly disconnect\r\n      disconnect()\r\n\r\n      // explicitly connect again\r\n      connect()\r\n\r\n      ...\r\n\r\n    }\r\n\r\nIn the next section, we will see how to execute remote commands.\r\n\r\n### Executing commands\r\n\r\nThe simplest way to execute a command within a remote session is by using the `exec` method that just takes a command string:\r\n\r\n    engine.remoteSession {\r\n      exec 'ls -la'\r\n    }\r\n\r\nYou can also pass a list of commands in an array:\r\n\r\n    exec([\r\n     'ls -la',\r\n     'date'\r\n    ])\r\n\r\nThe `exec` behavior can also be controlled with additional named parameters given to the method. For example, in order\r\nto hide commands output, you can use the following syntax:\r\n\r\n    exec(command: 'ls –la', showOutput: false)\r\n\r\nThe additional Parameter names are specified in the \"Configuration options\" section for the `execOptions`. They can all\r\nbe used to override default settings for specific commands.\r\n\r\nIn the same way, you can also define common parameters for a block of commands passed as an array:\r\n\r\n    exec(showOutput: false, command: [\r\n     'ls -la',\r\n     'date'\r\n    ])\r\n\r\nAlso you can get access to command output, exit code and exception thrown during command execution. This can be useful\r\nfor implementing logic based on a result returned by the remote command and/or parsing of the output. For example,\r\n\r\n    def result = exec(command: '/usr/bin/mycmd', failOnError: false, showOutput: false)\r\n    if (result.exitStatus == 1) {\r\n      result.output.eachLine { line ->\r\n        if (line.contains('WARNING')) {\r\n          throw new RuntimeException(\"Warning!!!\")\r\n        }\r\n      }\r\n    }\r\n\r\nTwo additional methods that you can use around your commands are `prefix` and `suffix`. They are similar to using the `prefix`\r\nand `suffix` options in `execOptions` or named parameters to `exec` method.\r\n\r\n    prefix(\"sudo\") {\r\n      exec 'ls -la'\r\n      exec 'df -h'\r\n    }\r\n\r\nAnd with `suffix`:\r\n\r\n    suffix(\">> output.log\") {\r\n      exec 'ls -la'\r\n      exec 'df -h'\r\n      exec 'date'\r\n      exec 'facter'\r\n    }\r\n\r\n \r\n### File uploading/downloading\r\n\r\nThe simplest way to modify a remote text file content is by using `remoteFile` method, which returns a remote\r\nfile object instance, and assign some string to the `text` property:\r\n\r\n    remoteFile('/etc/yum.repos.d/puppet.repo').text = '''\r\n      [puppet]\r\n      name=Puppet Labs Packages\r\n      baseurl=http://yum.puppetlabs.com/el/$releasever/products/$basearch/\r\n      enabled=0\r\n      gpgcheck=0\r\n    '''\r\n\r\nEach line of the input string will be trimmed before it's copied to the remote file.\r\nFor text file downloading you can just read the `text` property:\r\n\r\n    println remoteFile('/etc/yum.repos.d/puppet.repo').text\r\n\r\nUploading of a single file can be done in the following way:\r\n\r\n    scp \"$buildDir/test.file\", '/tmp/test.file'\r\n\r\nThis method only works for file uploading (from local environment to remote). You can also write the example above\r\nin a more verbose form with the help of closures:\r\n\r\n    scp {\r\n      from { localFile \"$buildDir/test.file\" }\r\n      into { remoteFile '/tmp/test.file' }\r\n    }\r\n\r\nA whole directory can be uploaded by using the `remoteDir` and `localDir` methods of `scp`.\r\n\r\n    scp {\r\n      from { localDir \"$buildDir/application\" }\r\n      into { remoteDir '/var/bea/domain/application' }\r\n    }\r\n\r\nIn similar fashion, you can download directories and files:\r\n\r\n    scp {\r\n      from { remoteDir '/etc/nginx' }\r\n      into { localDir \"$buildDir/nginx\" }\r\n    }\r\n\r\nYou can also copy multiple sources into multiple targets:\r\n\r\n    scp {\r\n      from {\r\n        localDir \"$buildDir/doc\"\r\n        localFile \"$buildDir/readme.txt\"\r\n        localFile \"$buildDir/license/license.txt\"\r\n      }\r\n      into {\r\n        remoteDir '/var/server/application'\r\n        remoteDir '/repo/company/application'\r\n      }\r\n    }\r\n\r\nDuring any upload/download operation, local and remote directories will be created automatically.\r\n\r\n### Tunneling\r\n\r\nIf inside your build script you need to get access to a remote server that is not visible directly from the local\r\nmachine, then you can create a tunnel to that server by using the `tunnel` method:\r\n\r\n    tunnel('1.2.3.4', 8080) { int localPort ->\r\n      ...\r\n    }\r\n\r\nAll code executed within the closure passed to the tunnel method will have access to a server tunnel running on `localhost`\r\nand randomly selected `localPort`, which is passed as a parameter to the closure. Inside that tunnel code you can, for\r\nexample, deploy a web application or send some **HTTP** command to remote server:\r\n\r\n    tunnel('1.2.3.4', 8080) { int localPort ->\r\n      def result = new URL(\"http://localhost:${localPort}/flushCache\").text\r\n      if (result == 'OK') {\r\n        println \"Cache is flushed!\"\r\n      } else {\r\n        throw new RuntimeException(result)\r\n      }\r\n    }\r\n\r\nThe tunnel will be closed upon closure completion.\r\nAlso you can define a local port yourself in the following way:\r\n\r\n    tunnel(7070, '1.2.3.4', 8080) {\r\n      def result = new URL(\"http://localhost:7070/flushCache\").text\r\n      ...\r\n    }\r\n\r\n### Configuration options\r\n\r\nThe following list gives an overview of the available configuration options:\r\n\r\n - `defaultHost`, `defaultUser`, `defaultPassword`, `defaultPort` (defaults to 22) - Default host, user name, password or port to use in remote connection in case they are not specified in some other way (through `url`, `host`, `port`, `user` or `password` properties inside the `remoteSession` method).\r\n - `defaultKeyFile` - Default key file to use in remote connection in case it is not specified through the `keyFile` property inside the `remoteSession` method.\r\n - `failOnError` (defaults to true) - If set to true, failed remote commands and file operations will throw an exception.\r\n - `verbose` (defaults to false) - If set to true, the library produces more debug output.\r\n\r\nThe `sshOptions` may also contain a nested `execOptions` structure, which defines remote command execution (see\r\n\"Executing commands\" section) options. It has the following properties:\r\n\r\n - `showOutput` (defaults to true) - If set to true, remote command output is printed.\r\n - `showCommand` (defaults to true) - If set to true, remote command is printed.\r\n - `maxWait` (defaults to 0) - Number of milliseconds to wait for command to finish. If it is set to 0, then library will wait forever.\r\n - `succeedOnExitStatus` (defaults to 0) - Exit code that indicates commands success. If command returns different exit code, then build will fail.\r\n - `outputFile` - File, to which to send command's output.\r\n - `appendFile` (defaults to false) - If outputFile is specified, then this option indicates if data should be appended or file should be created from scratch.\r\n - `failOnError` (defaults to true) - If set to true, failed remote commands will fail the build.\r\n - `verbose` (defaults to false) - If set to true, library produces more debug output.\r\n - `prefix` - String to prepend to each executed command, for example, \"`sudo`\".\r\n - `suffix` - String to append to each executed command, for example, \"`>> output.log`\".\r\n\r\nThere is also a nested `scpOptions` structure, which defines remote file copying options (see \"File uploading/downloading\"\r\nsection). It has the following properties:\r\n\r\n - `failOnError` (defaults to true) - If set to true, failed file operations will fail the build.\r\n - `showProgress` (defaults to false) - If set to true, library shows additional information regarding file upload/download progress.\r\n - `verbose` (defaults to false) - If set to true, library produces more debug output.\r\n\r\n### Populating SshOptions\r\n\r\nA more verbose example of creating a `SshOptions` object can be found below:\r\n\r\n    import com.aestasit.ssh.log.SysOutLogger\r\n\r\n    ...\r\n\r\n    options = new SshOptions()\r\n    options.with {\r\n\r\n      logger = new SysOutLogger()\r\n\r\n      defaultHost = '127.0.0.1'\r\n      defaultUser = 'user1'\r\n      defaultPassword = '123456'\r\n      defaultPort = 2233\r\n\r\n      reuseConnection = true\r\n      trustUnknownHosts = true\r\n\r\n      execOptions.with {\r\n        showOutput = true\r\n        failOnError = false\r\n        succeedOnExitStatus = 0\r\n        maxWait = 30000\r\n        outputFile = new File(\"output.file\")\r\n        appendFile = true\r\n      }\r\n\r\n      scpOptions.with {\r\n        verbose = true\r\n        showProgress = true\r\n      }\r\n\r\n    }\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}